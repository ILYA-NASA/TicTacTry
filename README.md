# TicTacTry
попытка разбить на команду написание крестиков-ноликов

<Крестики-нолики для двух игроков( с возможностью второй игрок = бот)>
1. Печать поля(вход list, выход list, можно без выхода). - Serega
2. Ввод пользователя.Проверка заполненности ячейки. (вход list, метка (X или О, или bool), выход int:1-9,метка,list (совпадает со входом на 6)  - Илья 
3. Мозги бота(вход метка (X или О), вход list,  выход int:1-9, метка (X или О),list (совпадает со входом на 6)) - Антон Сизых
4. Проверка победы.(вход массив(List), выход флаг(bool) победы)  
5. Начало игры крестики или нолики? (сделали выход символа (X или О))   - Таня
6. Запись хода на поле(вход int:1-9,метка игрока,list,  выход list, bool на записан ход или нет). Зачем нужна эта функция ? Чтобы расшифровывать цифру поля на двумерный список и проверять валидность хода(пустое ли поле). Пока нагрузили этим  функцию 2 Ильи :) . В идеале, она будет вызываться как внутренняя функция внутри ф2 и ф3.
7. Сборная функция(наш main,в котором вызываются  вышеописанные функции)

нумерация  

    1 2 3
    4 5 6
    7 8 9
наполнение

  ("X ,"O"," ") (заглавная латиница)
  Пример списка с состоянием поля list_game = [['x','o','o'],['o','x','x'],['x','o',' ']] . Чтобы победить, нужно сделать запись в 9-е поле, list_game[2][2] ='x'
  
  
  Как работает сборная функция - так как она сильно связана с проверкой победы и ничьи, то от того,какая будет функция 4 сильно будет зависеть. Пока наиболее готовая версия функции 4 у Гены, так что отталкиваемся от его логики.
  
 1) Старт, импорт всех подфункций.
 2) Вызываем функцию 5 и определяем, чем играет пользователь.
 3) 3) Если у игрока метка крестиков - вызываем ф2.
 4) Передаем ответ в ф6.
 5) Если у игрока нолики - спрашиваем в консоли, играет ли он с ботом или с живым игроком 2    # этот шаг как раз можно добавить в функцию 5, и возращать помимо метки 1го игрока символом еще метку bot = False или true
 6) Проверяем ответ на косяки, потом либо вызываем мозги бота ф3, либо ф2 для игрока 2(метка O)
 7) Каждый вызов ф2 и ф3 считается в сборной функции по переменной счетчика и находится внутри цикла.
 8) На счетчике = 5 начинает вызываться ф4  после каждой ф2 и ф3.
 9) Если ф4 выдала нам флаг победы = True, делаем return строки поздравительной надписи, можно с вариацией расшифровки метки игрока или победы бота
 10) По достижении счетчика = 9 , если флаг победы до сих пор = False , объявляется ничья, делаем return строковой надписи.
  
 Почему return ? Потому что он позволяет закончить игру в процессе, прямо изнутри цикла. Break, насколько я понял по докам, только прервет нам цикл со счетчиком ходов, и прогонит то ,что мы после цикла сделали(в нашем случае, return ничья)
 
  Делая и победу и ничью по return "строка", мы получаем возможность безопасно вызывать нашу игру просто через print(tictactoe_game()) 
  

PS: к чему можно стремиться, почитайте описание https://habr.com/ru/post/403903/ , а здесь сам код на lua https://github.com/echo-Mike/STTT
